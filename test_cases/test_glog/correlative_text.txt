glog_text1 = """
Analyze the following code (a code snippet of the repo `glog`):

// The demangler entry point.
bool Demangle(const char *mangled, char *out, size_t out_size) {
#if defined(GLOG_OS_WINDOWS)
#if defined(HAVE_DBGHELP)
  // When built with incremental linking, the Windows debugger
  // library provides a more complicated `Symbol->Name` with the
  // Incremental Linking Table offset, which looks like
  // `@ILT+1105(?func@Foo@@SAXH@Z)`. However, the demangler expects
  // only the mangled symbol, `?func@Foo@@SAXH@Z`. Fortunately, the
  // mangled symbol is guaranteed not to have parentheses,
  // so we search for `(` and extract up to `)`.
  //
  // Since we may be in a signal handler here, we cannot use `std::string`.
  char buffer[1024];  // Big enough for a sane symbol.
  const char *lparen = strchr(mangled, '(');
  if (lparen) {
    // Extract the string `(?...)`
    const char *rparen = strchr(lparen, ')');
    size_t length = static_cast<size_t>(rparen - lparen) - 1;
    strncpy(buffer, lparen + 1, length);
    buffer[length] = '\0';
    mangled = buffer;
  } // Else the symbol wasn't inside a set of parentheses
  // We use the ANSI version to ensure the string type is always `char *`.
  return UnDecorateSymbolName(mangled, out, out_size, UNDNAME_COMPLETE);
#else
  (void)mangled;
  (void)out;
  (void)out_size;
  return false;
#endif
#else
  State state;
  InitState(&state, mangled, out, out_size);
  return ParseTopLevelMangledName(&state) && !state.overflowed;
#endif
}
"""

glog_text2 = """
Generate a function called LLVMFuzzerTestOneInput, which accpets a `const unsigned char *` type variable called `data` and a `unsigned` type variable called `Size` as the parameter of the inputs, 
and be able to invoke the function `Demangle`.
"""