/home/victor/workspace/fuzzing_target_repo/assimp/code/Common/BaseProcess.h:
    1|       |/*
    2|       |Open Asset Import Library (assimp)
    3|       |----------------------------------------------------------------------
    4|       |
    5|       |Copyright (c) 2006-2022, assimp team
    6|       |
    7|       |All rights reserved.
    8|       |
    9|       |Redistribution and use of this software in source and binary forms,
   10|       |with or without modification, are permitted provided that the
   11|       |following conditions are met:
   12|       |
   13|       |* Redistributions of source code must retain the above
   14|       |  copyright notice, this list of conditions and the
   15|       |  following disclaimer.
   16|       |
   17|       |* Redistributions in binary form must reproduce the above
   18|       |  copyright notice, this list of conditions and the
   19|       |  following disclaimer in the documentation and/or other
   20|       |  materials provided with the distribution.
   21|       |
   22|       |* Neither the name of the assimp team, nor the names of its
   23|       |  contributors may be used to endorse or promote products
   24|       |  derived from this software without specific prior
   25|       |  written permission of the assimp team.
   26|       |
   27|       |THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   28|       |"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   29|       |LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   30|       |A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   31|       |OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   32|       |SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   33|       |LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   34|       |DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   35|       |THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   36|       |(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   37|       |OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   38|       |
   39|       |----------------------------------------------------------------------
   40|       |*/
   41|       |
   42|       |/** @file Base class of all import post processing steps */
   43|       |#ifndef INCLUDED_AI_BASEPROCESS_H
   44|       |#define INCLUDED_AI_BASEPROCESS_H
   45|       |
   46|       |#include <assimp/GenericProperty.h>
   47|       |
   48|       |#include <map>
   49|       |
   50|       |struct aiScene;
   51|       |
   52|       |namespace Assimp {
   53|       |
   54|       |class Importer;
   55|       |
   56|       |// ---------------------------------------------------------------------------
   57|       |/** Helper class to allow post-processing steps to interact with each other.
   58|       | *
   59|       | *  The class maintains a simple property list that can be used by pp-steps
   60|       | *  to provide additional information to other steps. This is primarily
   61|       | *  intended for cross-step optimizations.
   62|       | */
   63|       |class SharedPostProcessInfo {
   64|       |public:
   65|       |    struct Base {
   66|       |        virtual ~Base() = default;
   67|       |    };
   68|       |
   69|       |    //! Represents data that is allocated on the heap, thus needs to be deleted
   70|       |    template <typename T>
   71|       |    struct THeapData : public Base {
   72|       |        explicit THeapData(T *in) :
   73|       |                data(in) {}
   74|       |
   75|       |        ~THeapData() {
   76|       |            delete data;
   77|       |        }
   78|       |        T *data;
   79|       |    };
   80|       |
   81|       |    //! Represents static, by-value data not allocated on the heap
   82|       |    template <typename T>
   83|       |    struct TStaticData : public Base {
   84|       |        explicit TStaticData(T in) :
   85|       |                data(in) {}
   86|       |
   87|       |        ~TStaticData() = default;
   88|       |
   89|       |        T data;
   90|       |    };
   91|       |
   92|       |    // some typedefs for cleaner code
   93|       |    typedef unsigned int KeyType;
   94|       |    typedef std::map<KeyType, Base *> PropertyMap;
   95|       |
   96|       |public:
   97|       |    //! Destructor
   98|      0|    ~SharedPostProcessInfo() {
   99|      0|        Clean();
  100|      0|    }
  101|       |
  102|       |    //! Remove all stored properties from the table
  103|      0|    void Clean() {
  104|      0|        // invoke the virtual destructor for all stored properties
  105|      0|        for (PropertyMap::iterator it = pmap.begin(), end = pmap.end();
  106|      0|                it != end; ++it) {
  107|      0|            delete (*it).second;
  108|      0|        }
  109|      0|        pmap.clear();
  110|      0|    }
  111|       |
  112|       |    //! Add a heap property to the list
  113|       |    template <typename T>
  114|      0|    void AddProperty(const char *name, T *in) {
  115|      0|        AddProperty(name, (Base *)new THeapData<T>(in));
  116|      0|    }
  117|       |
  118|       |    //! Add a static by-value property to the list
  119|       |    template <typename T>
  120|       |    void AddProperty(const char *name, T in) {
  121|       |        AddProperty(name, (Base *)new TStaticData<T>(in));
  122|       |    }
  123|       |
  124|       |    //! Get a heap property
  125|       |    template <typename T>
  126|       |    bool GetProperty(const char *name, T *&out) const {
  127|       |        THeapData<T> *t = (THeapData<T> *)GetPropertyInternal(name);
  128|       |        if (!t) {
  129|       |            out = nullptr;
  130|       |            return false;
  131|       |        }
  132|       |        out = t->data;
  133|       |        return true;
  134|       |    }
  135|       |
  136|       |    //! Get a static, by-value property
  137|       |    template <typename T>
  138|       |    bool GetProperty(const char *name, T &out) const {
  139|       |        TStaticData<T> *t = (TStaticData<T> *)GetPropertyInternal(name);
  140|       |        if ( nullptr == t) {
  141|       |            return false;
  142|       |        }
  143|       |        out = t->data;
  144|       |        return true;
  145|       |    }
  146|       |
  147|       |    //! Remove a property of a specific type
  148|      0|    void RemoveProperty(const char *name) {
  149|      0|        SetGenericPropertyPtr<Base>(pmap, name, nullptr );
  150|      0|    }
  151|       |
  152|       |private:
  153|      0|    void AddProperty(const char *name, Base *data) {
  154|      0|        SetGenericPropertyPtr<Base>(pmap, name, data);
  155|      0|    }
  156|       |
  157|      0|    Base *GetPropertyInternal(const char *name) const {
  158|      0|        return GetGenericProperty<Base *>(pmap, name, nullptr );
  159|      0|    }
  160|       |
  161|       |private:
  162|       |    //! Map of all stored properties
  163|       |    PropertyMap pmap;
  164|       |};
  165|       |
  166|       |#define AI_SPP_SPATIAL_SORT "$Spat"
  167|       |
  168|       |// ---------------------------------------------------------------------------
  169|       |/** The BaseProcess defines a common interface for all post processing steps.
  170|       | * A post processing step is run after a successful import if the caller
  171|       | * specified the corresponding flag when calling ReadFile().
  172|       | * Enum #aiPostProcessSteps defines which flags are available.
  173|       | * After a successful import the Importer iterates over its internal array
  174|       | * of processes and calls IsActive() on each process to evaluate if the step
  175|       | * should be executed. If the function returns true, the class' Execute()
  176|       | * function is called subsequently.
  177|       | */
  178|       |class ASSIMP_API BaseProcess {
  179|       |    friend class Importer;
  180|       |
  181|       |public:
  182|       |    /** @brief onstructor to be privately used by Importer */
  183|       |    BaseProcess() AI_NO_EXCEPT;
  184|       |
  185|       |    /** @brief Destructor, private as well */
  186|       |    virtual ~BaseProcess();
  187|       |
  188|       |    // -------------------------------------------------------------------
  189|       |    /**
  190|       |     * @brief Returns whether the processing step is present in the given flag.
  191|       |     * @param pFlags The processing flags the importer was called with. A
  192|       |     *   bitwise combination of #aiPostProcessSteps.
  193|       |     * @return true if the process is present in this flag fields,
  194|       |     *   false if not.
  195|       |     */
  196|       |    virtual bool IsActive(unsigned int pFlags) const = 0;
  197|       |
  198|       |    // -------------------------------------------------------------------
  199|       |    /** Check whether this step expects its input vertex data to be
  200|       |     *  in verbose format. */
  201|       |    virtual bool RequireVerboseFormat() const;
  202|       |
  203|       |    // -------------------------------------------------------------------
  204|       |    /**
  205|       |     * @brief Executes the post processing step on the given imported data.
  206|       |     * The function deletes the scene if the post-process step fails (
  207|       |     * the object pointer will be set to nullptr).
  208|       |     * @param pImp Importer instance (pImp->mScene must be valid)
  209|       |     */
  210|       |    void ExecuteOnScene(Importer *pImp);
  211|       |
  212|       |    // -------------------------------------------------------------------
  213|       |    /**
  214|       |     * @brief Called prior to ExecuteOnScene().
  215|       |     * The function is a request to the process to update its configuration
  216|       |     * basing on the Importer's configuration property list.
  217|       |     */
  218|       |    virtual void SetupProperties(const Importer *pImp);
  219|       |
  220|       |    // -------------------------------------------------------------------
  221|       |    /**
  222|       |     * @brief Executes the post processing step on the given imported data.
  223|       |     * A process should throw an ImportErrorException* if it fails.
  224|       |     * This method must be implemented by deriving classes.
  225|       |     * @param pScene The imported data to work at.
  226|       |     */
  227|       |    virtual void Execute(aiScene *pScene) = 0;
  228|       |
  229|       |    // -------------------------------------------------------------------
  230|       |    /** Assign a new SharedPostProcessInfo to the step. This object
  231|       |     *  allows multiple post-process steps to share data.
  232|       |     * @param sh May be nullptr
  233|       |     */
  234|      0|    inline void SetSharedData(SharedPostProcessInfo *sh) {
  235|      0|        shared = sh;
  236|      0|    }
  237|       |
  238|       |    // -------------------------------------------------------------------
  239|       |    /** Get the shared data that is assigned to the step.
  240|       |    */
  241|      0|    inline SharedPostProcessInfo *GetSharedData() {
  242|      0|        return shared;
  243|      0|    }
  244|       |
  245|       |protected:
  246|       |    /** See the doc of #SharedPostProcessInfo for more details */
  247|       |    SharedPostProcessInfo *shared;
  248|       |
  249|       |    /** Currently active progress handler */
  250|       |    ProgressHandler *progress;
  251|       |};
  252|       |
  253|       |} // end of namespace Assimp
  254|       |
  255|       |#endif // AI_BASEPROCESS_H_INC

/home/victor/workspace/fuzzing_target_repo/assimp/code/Common/DefaultProgressHandler.h:
    1|       |/*
    2|       |Open Asset Import Library (assimp)
    3|       |----------------------------------------------------------------------
    4|       |
    5|       |Copyright (c) 2006-2022, assimp team
    6|       |
    7|       |All rights reserved.
    8|       |
    9|       |Redistribution and use of this software in source and binary forms,
   10|       |with or without modification, are permitted provided that the
   11|       |following conditions are met:
   12|       |
   13|       |* Redistributions of source code must retain the above
   14|       |  copyright notice, this list of conditions and the
   15|       |  following disclaimer.
   16|       |
   17|       |* Redistributions in binary form must reproduce the above
   18|       |  copyright notice, this list of conditions and the
   19|       |  following disclaimer in the documentation and/or other
   20|       |  materials provided with the distribution.
   21|       |
   22|       |* Neither the name of the assimp team, nor the names of its
   23|       |  contributors may be used to endorse or promote products
   24|       |  derived from this software without specific prior
   25|       |  written permission of the assimp team.
   26|       |
   27|       |THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   28|       |"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   29|       |LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   30|       |A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   31|       |OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   32|       |SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   33|       |LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   34|       |DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   35|       |THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   36|       |(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   37|       |OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   38|       |
   39|       |----------------------------------------------------------------------
   40|       |*/
   41|       |
   42|       |/** @file ProgressHandler.hpp
   43|       | *  @brief Abstract base class 'ProgressHandler'.
   44|       | */
   45|       |#ifndef INCLUDED_AI_DEFAULTPROGRESSHANDLER_H
   46|       |#define INCLUDED_AI_DEFAULTPROGRESSHANDLER_H
   47|       |
   48|       |#include <assimp/ProgressHandler.hpp>
   49|       |
   50|       |namespace Assimp {
   51|       |
   52|       |// ------------------------------------------------------------------------------------
   53|       |/**
   54|       | *  @brief Internal default implementation of the #ProgressHandler interface.
   55|       | */
   56|       |class DefaultProgressHandler : public ProgressHandler    {
   57|       |public:
   58|       |    ///	@brief Ignores the update callback.
   59|      0|    bool Update(float) override {
   60|      0|        return false;
   61|      0|    }
   62|       |};
   63|       |
   64|       |} // Namespace Assimp
   65|       |
   66|       |#endif // INCLUDED_AI_DEFAULTPROGRESSHANDLER_H

/home/victor/workspace/fuzzing_target_repo/assimp/code/Common/Importer.h:
    1|       |/*
    2|       |Open Asset Import Library (assimp)
    3|       |----------------------------------------------------------------------
    4|       |
    5|       |Copyright (c) 2006-2022, assimp team
    6|       |
    7|       |All rights reserved.
    8|       |
    9|       |Redistribution and use of this software in source and binary forms,
   10|       |with or without modification, are permitted provided that the
   11|       |following conditions are met:
   12|       |
   13|       |* Redistributions of source code must retain the above
   14|       |  copyright notice, this list of conditions and the
   15|       |  following disclaimer.
   16|       |
   17|       |* Redistributions in binary form must reproduce the above
   18|       |  copyright notice, this list of conditions and the
   19|       |  following disclaimer in the documentation and/or other
   20|       |  materials provided with the distribution.
   21|       |
   22|       |* Neither the name of the assimp team, nor the names of its
   23|       |  contributors may be used to endorse or promote products
   24|       |  derived from this software without specific prior
   25|       |  written permission of the assimp team.
   26|       |
   27|       |THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   28|       |"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   29|       |LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   30|       |A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   31|       |OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   32|       |SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   33|       |LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   34|       |DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   35|       |THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   36|       |(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   37|       |OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   38|       |
   39|       |----------------------------------------------------------------------
   40|       |*/
   41|       |
   42|       |/** @file Importer.h mostly internal stuff for use by #Assimp::Importer */
   43|       |#pragma once
   44|       |#ifndef INCLUDED_AI_IMPORTER_H
   45|       |#define INCLUDED_AI_IMPORTER_H
   46|       |
   47|       |#include <exception>
   48|       |#include <map>
   49|       |#include <vector>
   50|       |#include <string>
   51|       |#include <assimp/matrix4x4.h>
   52|       |
   53|       |struct aiScene;
   54|       |
   55|       |namespace Assimp    {
   56|       |    class ProgressHandler;
   57|       |    class IOSystem;
   58|       |    class BaseImporter;
   59|       |    class BaseProcess;
   60|       |    class SharedPostProcessInfo;
   61|       |
   62|       |
   63|       |//! @cond never
   64|       |// ---------------------------------------------------------------------------
   65|       |/** @brief Internal PIMPL implementation for Assimp::Importer
   66|       | *
   67|       | *  Using this idiom here allows us to drop the dependency from
   68|       | *  std::vector and std::map in the public headers. Furthermore we are dropping
   69|       | *  any STL interface problems caused by mismatching STL settings. All
   70|       | *  size calculation are now done by us, not the app heap. */
   71|       |class ImporterPimpl {
   72|       |public:
   73|       |    // Data type to store the key hash
   74|       |    typedef unsigned int KeyType;
   75|       |
   76|       |    // typedefs for our configuration maps.
   77|       |    typedef std::map<KeyType, int> IntPropertyMap;
   78|       |    typedef std::map<KeyType, ai_real> FloatPropertyMap;
   79|       |    typedef std::map<KeyType, std::string> StringPropertyMap;
   80|       |    typedef std::map<KeyType, aiMatrix4x4> MatrixPropertyMap;
   81|       |    typedef std::map<KeyType, void*> PointerPropertyMap;
   82|       |
   83|       |    /** IO handler to use for all file accesses. */
   84|       |    IOSystem* mIOHandler;
   85|       |    bool mIsDefaultHandler;
   86|       |
   87|       |    /** Progress handler for feedback. */
   88|       |    ProgressHandler* mProgressHandler;
   89|       |    bool mIsDefaultProgressHandler;
   90|       |
   91|       |    /** Format-specific importer worker objects - one for each format we can read.*/
   92|       |    std::vector< BaseImporter* > mImporter;
   93|       |
   94|       |    /** Post processing steps we can apply at the imported data. */
   95|       |    std::vector< BaseProcess* > mPostProcessingSteps;
   96|       |
   97|       |    /** The imported data, if ReadFile() was successful, nullptr otherwise. */
   98|       |    aiScene* mScene;
   99|       |
  100|       |    /** The error description, if there was one. In the case of an exception,
  101|       |     *  mException will carry the full details. */
  102|       |    std::string mErrorString;
  103|       |
  104|       |    /** Any exception which occurred */
  105|       |    std::exception_ptr mException;
  106|       |
  107|       |    /** List of integer properties */
  108|       |    IntPropertyMap mIntProperties;
  109|       |
  110|       |    /** List of floating-point properties */
  111|       |    FloatPropertyMap mFloatProperties;
  112|       |
  113|       |    /** List of string properties */
  114|       |    StringPropertyMap mStringProperties;
  115|       |
  116|       |    /** List of Matrix properties */
  117|       |    MatrixPropertyMap mMatrixProperties;
  118|       |
  119|       |    /** List of pointer properties */
  120|       |    PointerPropertyMap mPointerProperties;
  121|       |
  122|       |    /** Used for testing - extra verbose mode causes the ValidateDataStructure-Step
  123|       |     *  to be executed before and after every single post-process step */
  124|       |    bool bExtraVerbose;
  125|       |
  126|       |    /** Used by post-process steps to share data */
  127|       |    SharedPostProcessInfo* mPPShared;
  128|       |
  129|       |    /// The default class constructor.
  130|       |    ImporterPimpl() AI_NO_EXCEPT;
  131|       |};
  132|       |
  133|       |inline
  134|       |ImporterPimpl::ImporterPimpl() AI_NO_EXCEPT :
  135|       |        mIOHandler( nullptr ),
  136|       |        mIsDefaultHandler( false ),
  137|       |        mProgressHandler( nullptr ),
  138|       |        mIsDefaultProgressHandler( false ),
  139|       |        mImporter(),
  140|       |        mPostProcessingSteps(),
  141|       |        mScene( nullptr ),
  142|       |        mErrorString(),
  143|       |        mException(),
  144|       |        mIntProperties(),
  145|       |        mFloatProperties(),
  146|       |        mStringProperties(),
  147|       |        mMatrixProperties(),
  148|       |        mPointerProperties(),
  149|       |        bExtraVerbose( false ),
  150|       |        mPPShared( nullptr ) {
  151|       |    // empty
  152|       |}
  153|       |//! @endcond
  154|       |
  155|       |struct BatchData;
  156|       |
  157|       |// ---------------------------------------------------------------------------
  158|       |/** FOR IMPORTER PLUGINS ONLY: A helper class to the pleasure of importers
  159|       | *  that need to load many external meshes recursively.
  160|       | *
  161|       | *  The class uses several threads to load these meshes (or at least it
  162|       | *  could, this has not yet been implemented at the moment).
  163|       | *
  164|       | *  @note The class may not be used by more than one thread*/
  165|       |class ASSIMP_API BatchLoader {
  166|       |public:
  167|       |    //! @cond never
  168|       |    // -------------------------------------------------------------------
  169|       |    /** Wraps a full list of configuration properties for an importer.
  170|       |     *  Properties can be set using SetGenericProperty */
  171|       |    struct PropertyMap {
  172|       |        ImporterPimpl::IntPropertyMap     ints;
  173|       |        ImporterPimpl::FloatPropertyMap   floats;
  174|       |        ImporterPimpl::StringPropertyMap  strings;
  175|       |        ImporterPimpl::MatrixPropertyMap  matrices;
  176|       |
  177|      0|        bool operator == (const PropertyMap& prop) const {
  178|      0|            // fixme: really isocpp? gcc complains
  179|      0|            return ints == prop.ints && floats == prop.floats && strings == prop.strings && matrices == prop.matrices;
  180|      0|        }
  181|       |
  182|      0|        bool empty () const {
  183|      0|            return ints.empty() && floats.empty() && strings.empty() && matrices.empty();
  184|      0|        }
  185|       |    };
  186|       |    //! @endcond
  187|       |
  188|       |    // -------------------------------------------------------------------
  189|       |    /** Construct a batch loader from a given IO system to be used
  190|       |     *  to access external files
  191|       |     */
  192|       |    explicit BatchLoader(IOSystem* pIO, bool validate = false );
  193|       |
  194|       |    // -------------------------------------------------------------------
  195|       |    /** The class destructor.
  196|       |     */
  197|       |    ~BatchLoader();
  198|       |
  199|       |    // -------------------------------------------------------------------
  200|       |    /** Sets the validation step. True for enable validation during postprocess.
  201|       |     *  @param  enable  True for validation.
  202|       |     */
  203|       |    void setValidation( bool enabled );
  204|       |
  205|       |    // -------------------------------------------------------------------
  206|       |    /** Returns the current validation step.
  207|       |     *  @return The current validation step.
  208|       |     */
  209|       |    bool getValidation() const;
  210|       |
  211|       |    // -------------------------------------------------------------------
  212|       |    /** Add a new file to the list of files to be loaded.
  213|       |     *  @param file File to be loaded
  214|       |     *  @param steps Post-processing steps to be executed on the file
  215|       |     *  @param map Optional configuration properties
  216|       |     *  @return 'Load request channel' - an unique ID that can later
  217|       |     *    be used to access the imported file data.
  218|       |     *  @see GetImport */
  219|       |    unsigned int AddLoadRequest (
  220|       |        const std::string& file,
  221|       |        unsigned int steps = 0,
  222|       |            const PropertyMap *map = nullptr
  223|       |        );
  224|       |
  225|       |    // -------------------------------------------------------------------
  226|       |    /** Get an imported scene.
  227|       |     *  This polls the import from the internal request list.
  228|       |     *  If an import is requested several times, this function
  229|       |     *  can be called several times, too.
  230|       |     *
  231|       |     *  @param which LRWC returned by AddLoadRequest().
  232|       |     *  @return nullptr if there is no scene with this file name
  233|       |     *  in the queue of the scene hasn't been loaded yet. */
  234|       |    aiScene* GetImport(
  235|       |        unsigned int which
  236|       |        );
  237|       |
  238|       |    // -------------------------------------------------------------------
  239|       |    /** Waits until all scenes have been loaded. This returns
  240|       |     *  immediately if no scenes are queued.*/
  241|       |    void LoadAll();
  242|       |
  243|       |private:
  244|       |    // No need to have that in the public API ...
  245|       |    BatchData *m_data;
  246|       |};
  247|       |
  248|       |} // Namespace Assimp
  249|       |
  250|       |#endif // INCLUDED_AI_IMPORTER_H

/home/victor/workspace/fuzzing_target_repo/assimp/code/Common/ScenePreprocessor.h:
    1|       |/*
    2|       |Open Asset Import Library (assimp)
    3|       |----------------------------------------------------------------------
    4|       |
    5|       |Copyright (c) 2006-2022, assimp team
    6|       |
    7|       |
    8|       |All rights reserved.
    9|       |
   10|       |Redistribution and use of this software in source and binary forms,
   11|       |with or without modification, are permitted provided that the
   12|       |following conditions are met:
   13|       |
   14|       |* Redistributions of source code must retain the above
   15|       |  copyright notice, this list of conditions and the
   16|       |  following disclaimer.
   17|       |
   18|       |* Redistributions in binary form must reproduce the above
   19|       |  copyright notice, this list of conditions and the
   20|       |  following disclaimer in the documentation and/or other
   21|       |  materials provided with the distribution.
   22|       |
   23|       |* Neither the name of the assimp team, nor the names of its
   24|       |  contributors may be used to endorse or promote products
   25|       |  derived from this software without specific prior
   26|       |  written permission of the assimp team.
   27|       |
   28|       |THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   29|       |"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   30|       |LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   31|       |A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   32|       |OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   33|       |SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   34|       |LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   35|       |DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   36|       |THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   37|       |(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   38|       |OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   39|       |
   40|       |----------------------------------------------------------------------
   41|       |*/
   42|       |
   43|       |/** @file Defines a post processing step to search all meshes for
   44|       |  degenerated faces */
   45|       |#ifndef AI_SCENE_PREPROCESSOR_H_INC
   46|       |#define AI_SCENE_PREPROCESSOR_H_INC
   47|       |
   48|       |#include <assimp/defs.h>
   49|       |#include <stddef.h>
   50|       |
   51|       |struct aiScene;
   52|       |struct aiAnimation;
   53|       |struct aiMesh;
   54|       |
   55|       |class ScenePreprocessorTest;
   56|       |namespace Assimp {
   57|       |
   58|       |// ----------------------------------------------------------------------------------
   59|       |/** ScenePreprocessor: Preprocess a scene before any post-processing
   60|       | *  steps are executed.
   61|       | *
   62|       | *  The step computes data that needn't necessarily be provided by the
   63|       | *  importer, such as aiMesh::mPrimitiveTypes.
   64|       |*/
   65|       |// ----------------------------------------------------------------------------------
   66|       |class ASSIMP_API ScenePreprocessor {
   67|       |    // Make ourselves a friend of the corresponding test unit.
   68|       |    friend class ::ScenePreprocessorTest;
   69|       |
   70|       |public:
   71|       |    // ----------------------------------------------------------------
   72|       |    /** Default c'tpr. Use SetScene() to assign a scene to the object.
   73|       |     */
   74|       |    ScenePreprocessor() :
   75|      0|            scene(nullptr) {}
   76|       |
   77|       |    /** Constructs the object and assigns a specific scene to it
   78|       |     */
   79|       |    ScenePreprocessor(aiScene *_scene) :
   80|      0|            scene(_scene) {}
   81|       |
   82|       |    // ----------------------------------------------------------------
   83|       |    /** Assign a (new) scene to the object.
   84|       |     *
   85|       |     *  One 'SceneProcessor' can be used for multiple scenes.
   86|       |     *  Call ProcessScene to have the scene preprocessed.
   87|       |     *  @param sc Scene to be processed.
   88|       |     */
   89|      0|    void SetScene(aiScene *sc) {
   90|      0|        scene = sc;
   91|      0|    }
   92|       |
   93|       |    // ----------------------------------------------------------------
   94|       |    /** Preprocess the current scene
   95|       |     */
   96|       |    void ProcessScene();
   97|       |
   98|       |protected:
   99|       |    // ----------------------------------------------------------------
  100|       |    /** Preprocess an animation in the scene
  101|       |     *  @param anim Anim to be preprocessed.
  102|       |     */
  103|       |    void ProcessAnimation(aiAnimation *anim);
  104|       |
  105|       |    // ----------------------------------------------------------------
  106|       |    /** Preprocess a mesh in the scene
  107|       |     *  @param mesh Mesh to be preprocessed.
  108|       |     */
  109|       |    void ProcessMesh(aiMesh *mesh);
  110|       |
  111|       |protected:
  112|       |    //! Scene we're currently working on
  113|       |    aiScene *scene;
  114|       |};
  115|       |
  116|       |} // namespace Assimp
  117|       |
  118|       |#endif // include guard

/home/victor/workspace/fuzzing_target_repo/assimp/code/Common/ScenePrivate.h:
    1|       |/*
    2|       |Open Asset Import Library (assimp)
    3|       |----------------------------------------------------------------------
    4|       |
    5|       |Copyright (c) 2006-2022, assimp team
    6|       |
    7|       |
    8|       |All rights reserved.
    9|       |
   10|       |Redistribution and use of this software in source and binary forms,
   11|       |with or without modification, are permitted provided that the
   12|       |following conditions are met:
   13|       |
   14|       |* Redistributions of source code must retain the above
   15|       |  copyright notice, this list of conditions and the
   16|       |  following disclaimer.
   17|       |
   18|       |* Redistributions in binary form must reproduce the above
   19|       |  copyright notice, this list of conditions and the
   20|       |  following disclaimer in the documentation and/or other
   21|       |  materials provided with the distribution.
   22|       |
   23|       |* Neither the name of the assimp team, nor the names of its
   24|       |  contributors may be used to endorse or promote products
   25|       |  derived from this software without specific prior
   26|       |  written permission of the assimp team.
   27|       |
   28|       |THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   29|       |"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   30|       |LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   31|       |A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   32|       |OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   33|       |SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   34|       |LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   35|       |DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   36|       |THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   37|       |(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   38|       |OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   39|       |
   40|       |----------------------------------------------------------------------
   41|       |*/
   42|       |
   43|       |/** @file Stuff to deal with aiScene::mPrivate
   44|       | */
   45|       |#pragma once
   46|       |#ifndef AI_SCENEPRIVATE_H_INCLUDED
   47|       |#define AI_SCENEPRIVATE_H_INCLUDED
   48|       |
   49|       |#include <assimp/ai_assert.h>
   50|       |#include <assimp/scene.h>
   51|       |
   52|       |namespace Assimp {
   53|       |
   54|       |// Forward declarations
   55|       |class Importer;
   56|       |
   57|       |struct ScenePrivateData {
   58|       |    //  The struct constructor.
   59|       |    ScenePrivateData() AI_NO_EXCEPT;
   60|       |
   61|       |    // Importer that originally loaded the scene though the C-API
   62|       |    // If set, this object is owned by this private data instance.
   63|       |    Assimp::Importer* mOrigImporter;
   64|       |
   65|       |    // List of post-processing steps already applied to the scene.
   66|       |    unsigned int mPPStepsApplied;
   67|       |
   68|       |    // true if the scene is a copy made with aiCopyScene()
   69|       |    // or the corresponding C++ API. This means that user code
   70|       |    // may have made modifications to it, so mPPStepsApplied
   71|       |    // and mOrigImporter are no longer safe to rely on and only
   72|       |    // serve informative purposes.
   73|       |    bool mIsCopy;
   74|       |};
   75|       |
   76|       |inline
   77|       |ScenePrivateData::ScenePrivateData() AI_NO_EXCEPT
   78|       |: mOrigImporter( nullptr )
   79|       |, mPPStepsApplied( 0 )
   80|       |, mIsCopy( false ) {
   81|       |    // empty
   82|       |}
   83|       |
   84|       |// Access private data stored in the scene
   85|       |inline
   86|      0|ScenePrivateData* ScenePriv(aiScene* in) {
   87|      0|    ai_assert( nullptr != in );
   88|      0|    if ( nullptr == in ) {
   89|      0|        return nullptr;
   90|      0|    }
   91|      0|    return static_cast<ScenePrivateData*>(in->mPrivate);
   92|      0|}
   93|       |
   94|       |inline
   95|      0|const ScenePrivateData* ScenePriv(const aiScene* in) {
   96|      0|    ai_assert( nullptr != in );
   97|      0|    if ( nullptr == in ) {
   98|      0|        return nullptr;
   99|      0|    }
  100|      0|    return static_cast<const ScenePrivateData*>(in->mPrivate);
  101|      0|}
  102|       |
  103|       |} // Namespace Assimp
  104|       |
  105|       |#endif // AI_SCENEPRIVATE_H_INCLUDED

/home/victor/workspace/fuzzing_target_repo/assimp/code/PostProcessing/ProcessHelper.h:
    1|       |/*
    2|       |Open Asset Import Library (assimp)
    3|       |----------------------------------------------------------------------
    4|       |
    5|       |Copyright (c) 2006-2022, assimp team
    6|       |
    7|       |
    8|       |All rights reserved.
    9|       |
   10|       |Redistribution and use of this software in source and binary forms,
   11|       |with or without modification, are permitted provided that the
   12|       |following conditions are met:
   13|       |
   14|       |* Redistributions of source code must retain the above
   15|       |  copyright notice, this list of conditions and the
   16|       |  following disclaimer.
   17|       |
   18|       |* Redistributions in binary form must reproduce the above
   19|       |  copyright notice, this list of conditions and the
   20|       |  following disclaimer in the documentation and/or other
   21|       |  materials provided with the distribution.
   22|       |
   23|       |* Neither the name of the assimp team, nor the names of its
   24|       |  contributors may be used to endorse or promote products
   25|       |  derived from this software without specific prior
   26|       |  written permission of the assimp team.
   27|       |
   28|       |THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   29|       |"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   30|       |LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   31|       |A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   32|       |OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   33|       |SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   34|       |LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   35|       |DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   36|       |THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   37|       |(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   38|       |OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   39|       |
   40|       |----------------------------------------------------------------------
   41|       |*/
   42|       |
   43|       |#ifndef AI_PROCESS_HELPER_H_INCLUDED
   44|       |#define AI_PROCESS_HELPER_H_INCLUDED
   45|       |
   46|       |#include <assimp/anim.h>
   47|       |#include <assimp/material.h>
   48|       |#include <assimp/mesh.h>
   49|       |#include <assimp/postprocess.h>
   50|       |#include <assimp/scene.h>
   51|       |#include <assimp/DefaultLogger.hpp>
   52|       |
   53|       |#include "Common/BaseProcess.h"
   54|       |#include <assimp/ParsingUtils.h>
   55|       |#include <assimp/SpatialSort.h>
   56|       |
   57|       |#include <list>
   58|       |
   59|       |// -------------------------------------------------------------------------------
   60|       |// Some extensions to std namespace. Mainly std::min and std::max for all
   61|       |// flat data types in the aiScene. They're used to quickly determine the
   62|       |// min/max bounds of data arrays.
   63|       |#ifdef __cplusplus
   64|       |namespace std {
   65|       |
   66|       |// std::min for aiVector3D
   67|       |template <typename TReal>
   68|      0|inline ::aiVector3t<TReal> min(const ::aiVector3t<TReal> &a, const ::aiVector3t<TReal> &b) {
   69|      0|    return ::aiVector3t<TReal>(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z));
   70|      0|}
   71|       |
   72|       |// std::max for aiVector3t<TReal>
   73|       |template <typename TReal>
   74|      0|inline ::aiVector3t<TReal> max(const ::aiVector3t<TReal> &a, const ::aiVector3t<TReal> &b) {
   75|      0|    return ::aiVector3t<TReal>(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z));
   76|      0|}
   77|       |
   78|       |// std::min for aiVector2t<TReal>
   79|       |template <typename TReal>
   80|       |inline ::aiVector2t<TReal> min(const ::aiVector2t<TReal> &a, const ::aiVector2t<TReal> &b) {
   81|       |    return ::aiVector2t<TReal>(min(a.x, b.x), min(a.y, b.y));
   82|       |}
   83|       |
   84|       |// std::max for aiVector2t<TReal>
   85|       |template <typename TReal>
   86|       |inline ::aiVector2t<TReal> max(const ::aiVector2t<TReal> &a, const ::aiVector2t<TReal> &b) {
   87|       |    return ::aiVector2t<TReal>(max(a.x, b.x), max(a.y, b.y));
   88|       |}
   89|       |
   90|       |// std::min for aiColor4D
   91|       |template <typename TReal>
   92|       |inline ::aiColor4t<TReal> min(const ::aiColor4t<TReal> &a, const ::aiColor4t<TReal> &b) {
   93|       |    return ::aiColor4t<TReal>(min(a.r, b.r), min(a.g, b.g), min(a.b, b.b), min(a.a, b.a));
   94|       |}
   95|       |
   96|       |// std::max for aiColor4D
   97|       |template <typename TReal>
   98|       |inline ::aiColor4t<TReal> max(const ::aiColor4t<TReal> &a, const ::aiColor4t<TReal> &b) {
   99|       |    return ::aiColor4t<TReal>(max(a.r, b.r), max(a.g, b.g), max(a.b, b.b), max(a.a, b.a));
  100|       |}
  101|       |
  102|       |// std::min for aiQuaterniont<TReal>
  103|       |template <typename TReal>
  104|      0|inline ::aiQuaterniont<TReal> min(const ::aiQuaterniont<TReal> &a, const ::aiQuaterniont<TReal> &b) {
  105|      0|    return ::aiQuaterniont<TReal>(min(a.w, b.w), min(a.x, b.x), min(a.y, b.y), min(a.z, b.z));
  106|      0|}
  107|       |
  108|       |// std::max for aiQuaterniont<TReal>
  109|       |template <typename TReal>
  110|      0|inline ::aiQuaterniont<TReal> max(const ::aiQuaterniont<TReal> &a, const ::aiQuaterniont<TReal> &b) {
  111|      0|    return ::aiQuaterniont<TReal>(max(a.w, b.w), max(a.x, b.x), max(a.y, b.y), max(a.z, b.z));
  112|      0|}
  113|       |
  114|       |// std::min for aiVectorKey
  115|      0|inline ::aiVectorKey min(const ::aiVectorKey &a, const ::aiVectorKey &b) {
  116|      0|    return ::aiVectorKey(min(a.mTime, b.mTime), min(a.mValue, b.mValue));
  117|      0|}
  118|       |
  119|       |// std::max for aiVectorKey
  120|      0|inline ::aiVectorKey max(const ::aiVectorKey &a, const ::aiVectorKey &b) {
  121|      0|    return ::aiVectorKey(max(a.mTime, b.mTime), max(a.mValue, b.mValue));
  122|      0|}
  123|       |
  124|       |// std::min for aiQuatKey
  125|      0|inline ::aiQuatKey min(const ::aiQuatKey &a, const ::aiQuatKey &b) {
  126|      0|    return ::aiQuatKey(min(a.mTime, b.mTime), min(a.mValue, b.mValue));
  127|      0|}
  128|       |
  129|       |// std::max for aiQuatKey
  130|      0|inline ::aiQuatKey max(const ::aiQuatKey &a, const ::aiQuatKey &b) {
  131|      0|    return ::aiQuatKey(max(a.mTime, b.mTime), max(a.mValue, b.mValue));
  132|      0|}
  133|       |
  134|       |// std::min for aiVertexWeight
  135|      0|inline ::aiVertexWeight min(const ::aiVertexWeight &a, const ::aiVertexWeight &b) {
  136|      0|    return ::aiVertexWeight(min(a.mVertexId, b.mVertexId),static_cast<ai_real>(min(a.mWeight, b.mWeight)));
  137|      0|}
  138|       |
  139|       |// std::max for aiVertexWeight
  140|      0|inline ::aiVertexWeight max(const ::aiVertexWeight &a, const ::aiVertexWeight &b) {
  141|      0|    return ::aiVertexWeight(max(a.mVertexId, b.mVertexId), static_cast<ai_real>(max(a.mWeight, b.mWeight)));
  142|      0|}
  143|       |
  144|       |} // end namespace std
  145|       |#endif // !! C++
  146|       |
  147|       |namespace Assimp {
  148|       |
  149|       |// -------------------------------------------------------------------------------
  150|       |// Start points for ArrayBounds<T> for all supported Ts
  151|       |template <typename T>
  152|       |struct MinMaxChooser;
  153|       |
  154|       |template <>
  155|       |struct MinMaxChooser<float> {
  156|      0|    void operator()(float &min, float &max) {
  157|      0|        max = -1e10f;
  158|      0|        min = 1e10f;
  159|      0|    }
  160|       |};
  161|       |template <>
  162|       |struct MinMaxChooser<double> {
  163|      0|    void operator()(double &min, double &max) {
  164|      0|        max = -1e10;
  165|      0|        min = 1e10;
  166|      0|    }
  167|       |};
  168|       |template <>
  169|       |struct MinMaxChooser<unsigned int> {
  170|      0|    void operator()(unsigned int &min, unsigned int &max) {
  171|      0|        max = 0;
  172|      0|        min = (1u << (sizeof(unsigned int) * 8 - 1));
  173|      0|    }
  174|       |};
  175|       |
  176|       |template <typename T>
  177|       |struct MinMaxChooser<aiVector3t<T>> {
  178|      0|    void operator()(aiVector3t<T> &min, aiVector3t<T> &max) {
  179|      0|        max = aiVector3t<T>(-1e10f, -1e10f, -1e10f);
  180|      0|        min = aiVector3t<T>(1e10f, 1e10f, 1e10f);
  181|      0|    }
  182|       |};
  183|       |template <typename T>
  184|       |struct MinMaxChooser<aiVector2t<T>> {
  185|       |    void operator()(aiVector2t<T> &min, aiVector2t<T> &max) {
  186|       |        max = aiVector2t<T>(-1e10f, -1e10f);
  187|       |        min = aiVector2t<T>(1e10f, 1e10f);
  188|       |    }
  189|       |};
  190|       |template <typename T>
  191|       |struct MinMaxChooser<aiColor4t<T>> {
  192|       |    void operator()(aiColor4t<T> &min, aiColor4t<T> &max) {
  193|       |        max = aiColor4t<T>(-1e10f, -1e10f, -1e10f, -1e10f);
  194|       |        min = aiColor4t<T>(1e10f, 1e10f, 1e10f, 1e10f);
  195|       |    }
  196|       |};
  197|       |
  198|       |template <typename T>
  199|       |struct MinMaxChooser<aiQuaterniont<T>> {
  200|      0|    void operator()(aiQuaterniont<T> &min, aiQuaterniont<T> &max) {
  201|      0|        max = aiQuaterniont<T>(-1e10f, -1e10f, -1e10f, -1e10f);
  202|      0|        min = aiQuaterniont<T>(1e10f, 1e10f, 1e10f, 1e10f);
  203|      0|    }
  204|       |};
  205|       |
  206|       |template <>
  207|       |struct MinMaxChooser<aiVectorKey> {
  208|      0|    void operator()(aiVectorKey &min, aiVectorKey &max) {
  209|      0|        MinMaxChooser<double>()(min.mTime, max.mTime);
  210|      0|        MinMaxChooser<aiVector3D>()(min.mValue, max.mValue);
  211|      0|    }
  212|       |};
  213|       |template <>
  214|       |struct MinMaxChooser<aiQuatKey> {
  215|      0|    void operator()(aiQuatKey &min, aiQuatKey &max) {
  216|      0|        MinMaxChooser<double>()(min.mTime, max.mTime);
  217|      0|        MinMaxChooser<aiQuaternion>()(min.mValue, max.mValue);
  218|      0|    }
  219|       |};
  220|       |
  221|       |template <>
  222|       |struct MinMaxChooser<aiVertexWeight> {
  223|      0|    void operator()(aiVertexWeight &min, aiVertexWeight &max) {
  224|      0|        MinMaxChooser<unsigned int>()(min.mVertexId, max.mVertexId);
  225|      0|        MinMaxChooser<ai_real>()(min.mWeight, max.mWeight);
  226|      0|    }
  227|       |};
  228|       |
  229|       |// -------------------------------------------------------------------------------
  230|       |/** @brief Find the min/max values of an array of Ts
  231|       | *  @param in Input array
  232|       | *  @param size Number of elements to process
  233|       | *  @param[out] min minimum value
  234|       | *  @param[out] max maximum value
  235|       | */
  236|       |template <typename T>
  237|       |inline void ArrayBounds(const T *in, unsigned int size, T &min, T &max) {
  238|       |    MinMaxChooser<T>()(min, max);
  239|       |    for (unsigned int i = 0; i < size; ++i) {
  240|       |        min = std::min(in[i], min);
  241|       |        max = std::max(in[i], max);
  242|       |    }
  243|       |}
  244|       |
  245|       |// -------------------------------------------------------------------------------
  246|       |/** Little helper function to calculate the quadratic difference
  247|       | * of two colors.
  248|       | * @param pColor1 First color
  249|       | * @param pColor2 second color
  250|       | * @return Quadratic color difference */
  251|      0|inline ai_real GetColorDifference(const aiColor4D &pColor1, const aiColor4D &pColor2) {
  252|      0|    const aiColor4D c(pColor1.r - pColor2.r, pColor1.g - pColor2.g, pColor1.b - pColor2.b, pColor1.a - pColor2.a);
  253|      0|    return c.r * c.r + c.g * c.g + c.b * c.b + c.a * c.a;
  254|      0|}
  255|       |
  256|       |// -------------------------------------------------------------------------------
  257|       |/** @brief Extract single strings from a list of identifiers
  258|       | *  @param in Input string list.
  259|       | *  @param out Receives a list of clean output strings
  260|       | *  @sdee #AI_CONFIG_PP_OG_EXCLUDE_LIST */
  261|       |void ConvertListToStrings(const std::string &in, std::list<std::string> &out);
  262|       |
  263|       |// -------------------------------------------------------------------------------
  264|       |/** @brief Compute the AABB of a mesh after applying a given transform
  265|       | *  @param mesh Input mesh
  266|       | *  @param[out] min Receives minimum transformed vertex
  267|       | *  @param[out] max Receives maximum transformed vertex
  268|       | *  @param m Transformation matrix to be applied */
  269|       |void FindAABBTransformed(const aiMesh *mesh, aiVector3D &min, aiVector3D &max, const aiMatrix4x4 &m);
  270|       |
  271|       |// -------------------------------------------------------------------------------
  272|       |/** @brief Helper function to determine the 'real' center of a mesh
  273|       | *
  274|       | *  That is the center of its axis-aligned bounding box.
  275|       | *  @param mesh Input mesh
  276|       | *  @param[out] min Minimum vertex of the mesh
  277|       | *  @param[out] max maximum vertex of the mesh
  278|       | *  @param[out] out Center point */
  279|       |void FindMeshCenter(aiMesh *mesh, aiVector3D &out, aiVector3D &min, aiVector3D &max);
  280|       |
  281|       |// -------------------------------------------------------------------------------
  282|       |/** @brief Helper function to determine the 'real' center of a scene
  283|       | *
  284|       | *  That is the center of its axis-aligned bounding box.
  285|       | *  @param scene Input scene
  286|       | *  @param[out] min Minimum vertex of the scene
  287|       | *  @param[out] max maximum vertex of the scene
  288|       | *  @param[out] out Center point */
  289|       |void FindSceneCenter(aiScene *scene, aiVector3D &out, aiVector3D &min, aiVector3D &max);
  290|       |
  291|       |// -------------------------------------------------------------------------------
  292|       |// Helper function to determine the 'real' center of a mesh after applying a given transform
  293|       |void FindMeshCenterTransformed(aiMesh *mesh, aiVector3D &out, aiVector3D &min, aiVector3D &max, const aiMatrix4x4 &m);
  294|       |
  295|       |// -------------------------------------------------------------------------------
  296|       |// Helper function to determine the 'real' center of a mesh
  297|       |void FindMeshCenter(aiMesh *mesh, aiVector3D &out);
  298|       |
  299|       |// -------------------------------------------------------------------------------
  300|       |// Helper function to determine the 'real' center of a mesh after applying a given transform
  301|       |void FindMeshCenterTransformed(aiMesh *mesh, aiVector3D &out, const aiMatrix4x4 &m);
  302|       |
  303|       |// -------------------------------------------------------------------------------
  304|       |// Compute a good epsilon value for position comparisons on a mesh
  305|       |ai_real ComputePositionEpsilon(const aiMesh *pMesh);
  306|       |
  307|       |// -------------------------------------------------------------------------------
  308|       |// Compute a good epsilon value for position comparisons on a array of meshes
  309|       |ai_real ComputePositionEpsilon(const aiMesh *const *pMeshes, size_t num);
  310|       |
  311|       |// -------------------------------------------------------------------------------
  312|       |// Compute an unique value for the vertex format of a mesh
  313|       |unsigned int GetMeshVFormatUnique(const aiMesh *pcMesh);
  314|       |
  315|       |// defs for ComputeVertexBoneWeightTable()
  316|       |using PerVertexWeight = std::pair<unsigned int, float>;
  317|       |using VertexWeightTable = std::vector<PerVertexWeight>;
  318|       |
  319|       |// -------------------------------------------------------------------------------
  320|       |// Compute a per-vertex bone weight table
  321|       |VertexWeightTable *ComputeVertexBoneWeightTable(const aiMesh *pMesh);
  322|       |
  323|       |// -------------------------------------------------------------------------------
  324|       |// Get a string for a given aiTextureMapping
  325|       |const char *MappingTypeToString(aiTextureMapping in);
  326|       |
  327|       |// flags for MakeSubmesh()
  328|       |#define AI_SUBMESH_FLAGS_SANS_BONES 0x1
  329|       |
  330|       |// -------------------------------------------------------------------------------
  331|       |// Split a mesh given a list of faces to be contained in the sub mesh
  332|       |aiMesh *MakeSubmesh(const aiMesh *superMesh, const std::vector<unsigned int> &subMeshFaces, unsigned int subFlags);
  333|       |
  334|       |// -------------------------------------------------------------------------------
  335|       |// Utility post-process step to share the spatial sort tree between
  336|       |// all steps which use it to speedup its computations.
  337|       |class ComputeSpatialSortProcess : public BaseProcess {
  338|      0|    bool IsActive(unsigned int pFlags) const {
  339|      0|        return nullptr != shared && 0 != (pFlags & (aiProcess_CalcTangentSpace |
  340|      0|                                                           aiProcess_GenNormals | aiProcess_JoinIdenticalVertices));
  341|      0|    }
  342|       |
  343|      0|    void Execute(aiScene *pScene) {
  344|      0|        typedef std::pair<SpatialSort, ai_real> _Type;
  345|      0|        ASSIMP_LOG_DEBUG("Generate spatially-sorted vertex cache");
  346|      0|
  347|      0|        std::vector<_Type> *p = new std::vector<_Type>(pScene->mNumMeshes);
  348|      0|        std::vector<_Type>::iterator it = p->begin();
  349|      0|
  350|      0|        for (unsigned int i = 0; i < pScene->mNumMeshes; ++i, ++it) {
  351|      0|            aiMesh *mesh = pScene->mMeshes[i];
  352|      0|            _Type &blubb = *it;
  353|      0|            blubb.first.Fill(mesh->mVertices, mesh->mNumVertices, sizeof(aiVector3D));
  354|      0|            blubb.second = ComputePositionEpsilon(mesh);
  355|      0|        }
  356|      0|
  357|      0|        shared->AddProperty(AI_SPP_SPATIAL_SORT, p);
  358|      0|    }
  359|       |};
  360|       |
  361|       |// -------------------------------------------------------------------------------
  362|       |// ... and the same again to cleanup the whole stuff
  363|       |class DestroySpatialSortProcess : public BaseProcess {
  364|      0|    bool IsActive(unsigned int pFlags) const {
  365|      0|        return nullptr != shared && 0 != (pFlags & (aiProcess_CalcTangentSpace |
  366|      0|                                                        aiProcess_GenNormals | aiProcess_JoinIdenticalVertices));
  367|      0|    }
  368|       |
  369|      0|    void Execute(aiScene * /*pScene*/) {
  370|      0|        shared->RemoveProperty(AI_SPP_SPATIAL_SORT);
  371|      0|    }
  372|       |};
  373|       |
  374|       |} // namespace Assimp
  375|       |
  376|       |#endif // !! AI_PROCESS_HELPER_H_INCLUDED

/home/victor/workspace/semantic-kernel-Demo/test_fuzzer.cc:
    1|       |#include "Common/Importer.h"
    2|       |#include "Common/BaseProcess.h"
    3|       |#include "Common/DefaultProgressHandler.h"
    4|       |#include "PostProcessing/ProcessHelper.h"
    5|       |#include "Common/ScenePreprocessor.h"
    6|       |#include "Common/ScenePrivate.h"
    7|       |
    8|      0|extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    9|       |    // Create an instance of the Importer class
   10|      0|    Assimp::Importer importer;
   11|       |
   12|       |    // Optionally, set up any required properties or flags for the importer here
   13|       |    // ...
   14|       |
   15|       |    // Call the ReadFileFromMemory function with the provided data and size
   16|      0|    const aiScene* scene = importer.ReadFileFromMemory(static_cast<const void*>(data), size, 0 /* flags */, nullptr /* hint */);
   17|       |
   18|       |    // For fuzzing, we typically don't need to do anything with the scene
   19|       |    // However, if you want to check certain properties, you can do so here
   20|       |    // ...
   21|       |
   22|       |    // The return value is non-zero if the input is interesting (e.g., triggers a crash or bug)
   23|       |    // and zero otherwise. For now, we return zero to indicate successful processing of the input.
   24|      0|    return 0;
   25|      0|}
   26|       |

